use std::str::FromStr;
use crate::lexer::{UInt, ElementaryTypeName, Byte, Operator, Number, NumberUnit, BooleanLiteral};
use crate::ast::{PrimaryExpression, Expression, TypeName, FunctionCallArguments};

grammar;

pub TypeName: TypeName = {
    ElementaryTypeNameTerm => TypeName::Elementary(<>),
    UserDefinedTypeName => TypeName::UserDefined(<>),
    Mapping,
    ArrayTypeName
}

Mapping: TypeName = {
    "mapping" "(" <a:ElementaryTypeNameTerm> "=>" <b:TypeName> ")" =>
        TypeName::Mapping(a, Box::new(b))
}

ArrayTypeName: TypeName = {
    <a:TypeName> "[" <b:Expression?> "]" => TypeName::Array(Box::new(a), b)
}

pub UserDefinedTypeName: Vec<String> = {
    <a:Identifier> <b:("." Identifier)*> => {
        let mut v = vec![a];
        v.extend(b.iter().map(|x| x.1.clone()));
        v
    }
}

ExpressionTier1: Box<Expression> = {
    Expression PostfixTerm => Box::new(Expression::Postfix(<>)),
    ExpressionTier2,
}

ExpressionTier2: Box<Expression> = {
    MemberAccess => Box::new(Expression::MemberAccess(<>.0, <>.1)),
    ExpressionTier3,
}

ExpressionTier3: Box<Expression> = {
    IndexAccess => Box::new(Expression::IndexAccess(<>.0, <>.1)),
    ExpressionTier4,
}

ExpressionTier4: Box<Expression> = {
    <a:Expression> "(" <b:FunctionCallArguments> ")" =>
        Box::new(Expression::FunctionCall(a, b)),
    ExpressionTier5,
}

ExpressionTier5: Box<Expression> = {
    <a:PrefixTerm> <b:ExpressionTier1> => Box::new(
        Expression::Prefix(a, Box::new(Expression::Primary(b)))),
    ExpressionTier6
}

ExpressionTier6: Box<Expression> = {
    PrimaryExpression => Box::new(Expression::Primary(<>))
}

pub Expression: Box<Expression> = {
    ExpressionTier1,
    // Expression PostfixTerm => Box::new(Expression::Postfix(<>)),
   // NewExpression => Box::new(Expression::New(<>)),
    /// MemberAccess => Box::new(Expression::MemberAccess(<>.0, <>.1)),
    /// IndexAccess => Box::new(Expression::IndexAccess(<>.0, <>.1)),
    /// <a:Expression> "(" <b:FunctionCallArguments> ")" => Box::new(Expression::FunctionCall(a, b)),
   // "(" <a:Expression> ")" => Box::new(a),
    /// <a:PrefixTerm> <b:PrimaryExpression> => Box::new(
    ///     Expression::Prefix(a, Box::new(Expression::Primary(b)))),
    /// PrimaryExpression => Box::new(Expression::Primary(<>))
}

pub PrimaryExpression: PrimaryExpression = {
    BooleanLiteral => PrimaryExpression::BooleanLiteral(<>),
    NumberLiteral => PrimaryExpression::NumberLiteral(<>.0, <>.1),
    HexLiteral => PrimaryExpression::HexLiteral(<>),
    StringLiteral => PrimaryExpression::StringLiteral(<>),
    TupleExpression => PrimaryExpression::TupleExpression(<>),
    Identifier => PrimaryExpression::Identifier(<>),
    ElementaryTypeNameTerm => PrimaryExpression::ElementaryTypeName(<>),
}

ExpressionList: Vec<Box<Expression>> = {
    <a:Expression> <b:("," Expression)*> => {
        let mut v = vec![a];
        v.extend(b.iter().map(|x| x.1.clone()));
        v
    }
}

NameValueList: Vec<(String, Box<Expression>)> = {
    <a:Identifier> ":" <b:Expression> <c:("," Identifier ":" Expression)*> => {
        let mut v = vec![(a, b)];
        v.extend(c.iter().map(|x| (x.1.to_string(), x.3.clone())));
        v
    }
}

FunctionCallArguments: FunctionCallArguments = {
    "{" <a:NameValueList?> "}" => FunctionCallArguments::NameValueList(a),
    ExpressionList? => FunctionCallArguments::ExpressionList(<>)
}

pub NewExpression: TypeName = {
    "new" <a:TypeName> => a
}

pub MemberAccess: (Box<Expression>, String) = {
    <a:Expression> "." <b:Identifier> => (a, b)
}

pub IndexAccess: (Box<Expression>, Option<Box<Expression>>) = {
    <a:Expression> "[" <b:Expression?> "]" => (a, b)
}

pub BooleanLiteral: BooleanLiteral = {
    "true" => BooleanLiteral::True,
    "false" => BooleanLiteral::False,
}

pub NumberLiteral: (Number, Option<NumberUnit>) = {
    <a:Number> <b:(" " NumberUnit?)> => (a, b.1)
}

pub NumberUnit: NumberUnit = {
    "wei" => NumberUnit::Wei,
    "szabo" => NumberUnit::Szabo,
    "finney" => NumberUnit::Finney,
    "ether" => NumberUnit::Ether,
    "seconds" => NumberUnit::Seconds,
    "minutes" => NumberUnit::Minutes,
    "hours" => NumberUnit::Hours,
    "days" => NumberUnit::Days,
    "weeks" => NumberUnit::Weeks,
    "years" => NumberUnit::Years,
}

pub HexLiteral: String = <s:r#"hex("([0-9a-fA-F]{2})*"|'([0-9a-fA-F]{2}*)')"#> =>
    s[4..s.len()-1].to_string();

pub StringLiteral: String = <s:r#""([^"\r\n\\]|\\.)*""#> => s[1..s.len()-1].to_string();

pub Identifier: String = <s:r"[a-zA-Z_$][a-zA-Z_$0-9]*"> => s.to_string();

pub Number: Number = {
    <a:r"0x[0-9a-fA-F]+"> => Number::Hex(a.to_string()),
    <a:r"[0-9]+(\.[0-9]*)?([eE][0-9]+)?"> => Number::Decimal(a.to_string())
}

pub TupleExpression: Vec<Expression> = {
    "(" <a:Expression?> <b:("," Expression?)*> ")" => {
        let mut exprs = Vec::<Expression>::new();
        if a != None {
            exprs.push(*a.unwrap());
        }
        exprs.extend(b.iter()
            .filter(|x| x.1 != None)
            .map(|x| *x.1.as_ref().unwrap().clone()));
        exprs
    }
};

pub ElementaryTypeNameTerm: ElementaryTypeName = {
    "address" => ElementaryTypeName::Address,
    "bool" => ElementaryTypeName::Bool,
    "string" => ElementaryTypeName::String,
    <n:UIntTerm> => ElementaryTypeName::UInt(n),
    <n:ByteTerm> => ElementaryTypeName::Byte(n),
}

pub UIntTerm: UInt = {
    "uint" => UInt::UInt,
    "uint8" => UInt::UInt8,
    "uint16" => UInt::UInt16,
    "uint24" => UInt::UInt24,
    "uint32" => UInt::UInt32,
    "uint40" => UInt::UInt40,
    "uint48" => UInt::UInt48,
    "uint56" => UInt::UInt56,
    "uint64" => UInt::UInt64,
    "uint72" => UInt::UInt72,
    "uint80" => UInt::UInt80,
    "uint88" => UInt::UInt88,
    "uint96" => UInt::UInt96,
    "uint104" => UInt::UInt104,
    "uint112" => UInt::UInt112,
    "uint120" => UInt::UInt120,
    "uint128" => UInt::UInt128,
    "uint136" => UInt::UInt136,
    "uint144" => UInt::UInt144,
    "uint152" => UInt::UInt152,
    "uint160" => UInt::UInt160,
    "uint168" => UInt::UInt168,
    "uint176" => UInt::UInt176,
    "uint184" => UInt::UInt184,
    "uint192" => UInt::UInt192,
    "uint200" => UInt::UInt200,
    "uint208" => UInt::UInt208,
    "uint216" => UInt::UInt216,
    "uint224" => UInt::UInt224,
    "uint232" => UInt::UInt232,
    "uint240" => UInt::UInt240,
    "uint248" => UInt::UInt248,
    "uint256" => UInt::UInt256,
}

pub ByteTerm: Byte = {
    "byte" => Byte::Byte,
    "bytes" => Byte::Bytes,
    "bytes1" => Byte::Bytes1,
    "bytes2" => Byte::Bytes2,
    "bytes3" => Byte::Bytes3,
    "bytes4" => Byte::Bytes4,
    "bytes5" => Byte::Bytes5,
    "bytes6" => Byte::Bytes6,
    "bytes7" => Byte::Bytes7,
    "bytes8" => Byte::Bytes8,
    "bytes9" => Byte::Bytes9,
    "bytes10" => Byte::Bytes10,
    "bytes11" => Byte::Bytes11,
    "bytes12" => Byte::Bytes12,
    "bytes13" => Byte::Bytes13,
    "bytes14" => Byte::Bytes14,
    "bytes15" => Byte::Bytes15,
    "bytes16" => Byte::Bytes16,
    "bytes17" => Byte::Bytes17,
    "bytes18" => Byte::Bytes18,
    "bytes19" => Byte::Bytes19,
    "bytes20" => Byte::Bytes20,
    "bytes21" => Byte::Bytes21,
    "bytes22" => Byte::Bytes22,
    "bytes23" => Byte::Bytes23,
    "bytes24" => Byte::Bytes24,
    "bytes25" => Byte::Bytes25,
    "bytes26" => Byte::Bytes26,
    "bytes27" => Byte::Bytes27,
    "bytes28" => Byte::Bytes28,
    "bytes29" => Byte::Bytes29,
    "bytes30" => Byte::Bytes30,
    "bytes31" => Byte::Bytes31,
    "bytes32" => Byte::Bytes32,
}

pub PostfixTerm: Operator = {
    "++" => Operator::Increment,
    "--" => Operator::Decrement,
}

pub PrefixTerm: Operator = {
     "!" => Operator::Not,
    "~" => Operator::Unary,
    "delete" => Operator::Delete,
    "++" => Operator::Increment,
    "--" => Operator::Decrement,
    "+" => Operator::Plus,
    "-" => Operator::Minus,
}

pub OperatorTerm: Operator = {
    "++" => Operator::Increment,
    "--" => Operator::Decrement,
    "!" => Operator::Not,
    "~" => Operator::Unary,
    "delete" => Operator::Delete,
    "+" => Operator::Plus,
    "-" => Operator::Minus,
    "**" => Operator::Exp,
    "*" => Operator::Multiply,
    "/" => Operator::Divide,
    "%" => Operator::Mod,
    "<<" => Operator::LeftShift,
    ">>" => Operator::RightShift,
    "&" => Operator::BitwiseAnd,
    "^" => Operator::XOR,
    "|" => Operator::BitwiseOR,
    "<" => Operator::LT,
    ">" => Operator::GT,
    "<=" => Operator::GTEq,
    ">=" => Operator::LTEq,
    "==" => Operator::Eq,
    "!=" => Operator::NotEq,
    "&&" => Operator::And,
    "||" => Operator::Or,
    "?" => Operator::QuestionMark,
    ":" => Operator::Colon,
    "=" => Operator::AssignEq,
    "|=" => Operator::AssignOr,
    "^=" => Operator::AssignXOR,
    "&=" => Operator::AssignAnd,
    "<<=" => Operator::AssignLeftShift,
    ">>=" => Operator::AssignRightShift,
    "+=" => Operator::AssignAdd,
    "-=" => Operator::AssignSubtract,
    "*=" => Operator::AssignMultiply,
    "/=" => Operator::AssignDivide,
    "%=" => Operator::AssignMod,
    "(" => Operator::LeftParen,
    ")" => Operator::RightParen,
}
